// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

var sudoku = [
  0,
  0,
  1,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  7,
  0,
  0,
  5,
  0,
  8,
  0,
  0,
  0,
  3,
  0,
  0,
  7,
  2,
  6,
  0,
  0,
  8,
  1,
  0,
  0,
  6,
  0,
  0,
  5,
  0,
  0,
  0,
  4,
  0,
  0,
  0,
  0,
  0,
  2,
  6,
  4,
  7,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  0,
  0,
  4,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  7,
  0,
  0,
  9
];

if (sudoku.length !== 81) {
  throw {
        RE_EXN_ID: "Failure",
        _1: "Invalid sudoku",
        Error: new Error()
      };
}

function floor(n) {
  return Math.floor(n) | 0;
}

function toRows(sudoku) {
  var indexes = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8
    ].map(function (n) {
        return Math.imul(n, 9);
      });
  return indexes.map(function (start, end) {
              var end$1 = indexes[end + 1 | 0];
              if (end$1 !== undefined) {
                return sudoku.slice(start, end$1);
              } else {
                return sudoku.slice(start);
              }
            });
}

function toColumns(sudoku) {
  var indexes = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8
  ];
  return indexes.map(function (columnIndex) {
              return sudoku.filter(function (param, index) {
                          return index % 9 === columnIndex;
                        });
            });
}

function toBoxes(sudoku) {
  return Core__Array.reduceWithIndex(sudoku, [], (function (boxes, value, key) {
                var row = Math.floor(key / 9 | 0) | 0;
                var column = key % 9;
                var boxIndex = Math.imul(Math.floor(row / 3 | 0) | 0, 3) + (Math.floor(column / 3 | 0) | 0) | 0;
                var box = boxes[boxIndex];
                boxes[boxIndex] = box !== undefined ? (box.push(value), box) : [value];
                return boxes;
              }));
}

function getRowKeysForKey(key) {
  var key$1 = Math.imul(Math.floor(key / 9 | 0) | 0, 9);
  return [
          key$1,
          key$1 + 1 | 0,
          key$1 + 2 | 0,
          key$1 + 3 | 0,
          key$1 + 4 | 0,
          key$1 + 5 | 0,
          key$1 + 6 | 0,
          key$1 + 7 | 0,
          key$1 + 8 | 0
        ];
}

function getColumnKeysForKey(key) {
  var key$1 = key % 9;
  return [
          key$1,
          key$1 + 9 | 0,
          key$1 + 18 | 0,
          key$1 + 27 | 0,
          key$1 + 36 | 0,
          key$1 + 45 | 0,
          key$1 + 54 | 0,
          key$1 + 63 | 0,
          key$1 + 72 | 0
        ];
}

function getBoxKeysForKey(key) {
  var rowIndex = Math.floor(key / 9 | 0) | 0;
  var columnIndex = key % 9;
  var boxIndex = Math.imul(Math.floor(rowIndex / 3 | 0) | 0, 3) + (Math.floor(columnIndex / 3 | 0) | 0) | 0;
  var key$1 = Math.imul(Math.floor(boxIndex / 3 | 0) | 0, 27) + Math.imul(boxIndex % 3, 3) | 0;
  return [
          key$1,
          key$1 + 1 | 0,
          key$1 + 2 | 0,
          key$1 + 9 | 0,
          key$1 + 10 | 0,
          key$1 + 11 | 0,
          key$1 + 18 | 0,
          key$1 + 19 | 0,
          key$1 + 20 | 0
        ];
}

function toCandidates(sudoku) {
  var candidates = new Map();
  var rows = toRows(sudoku);
  var columns = toColumns(sudoku);
  var boxes = toBoxes(sudoku);
  sudoku.forEach(function (value, key) {
        if (value === 0) {
          candidates.set(key, [
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9
                ].filter(function (value) {
                    var rowIndex = Math.floor(key / 9 | 0) | 0;
                    var columnIndex = key % 9;
                    var boxIndex = Math.imul(Math.floor(rowIndex / 3 | 0) | 0, 3) + (Math.floor(columnIndex / 3 | 0) | 0) | 0;
                    var row = Core__Option.getExn(rows[rowIndex], undefined);
                    var column = Core__Option.getExn(columns[columnIndex], undefined);
                    var box = Core__Option.getExn(boxes[boxIndex], undefined);
                    return !(row.includes(value) || column.includes(value) || box.includes(value));
                  }));
          return ;
        }
        
      });
  return candidates;
}

function nakedSingleStrategy(sudoku, candidatesMapOpt) {
  var candidatesMap = candidatesMapOpt !== undefined ? Caml_option.valFromOption(candidatesMapOpt) : toCandidates(sudoku);
  Array.from(candidatesMap.entries()).forEach(function (param) {
        var possibleValues = param[1];
        if (possibleValues.length === 1) {
          sudoku[param[0]] = Core__Option.getExn(possibleValues[0], undefined);
          return ;
        }
        
      });
  return sudoku;
}

function nakedCandidateStrategy(sudoku, candidatesMapOpt) {
  var candidatesMap = candidatesMapOpt !== undefined ? Caml_option.valFromOption(candidatesMapOpt) : toCandidates(sudoku);
  Array.from(candidatesMap.entries()).forEach(function (param) {
        var key = param[0];
        var rowIndexes = getRowKeysForKey(key);
        var columnIndexes = getColumnKeysForKey(key);
        var boxIndexes = getBoxKeysForKey(key);
        var rowCandidates = rowIndexes.map(function (key) {
              return Core__Option.getOr(candidatesMap.get(key), []);
            });
        var columnCandidates = columnIndexes.map(function (key) {
              return Core__Option.getOr(candidatesMap.get(key), []);
            });
        var boxCandidates = boxIndexes.map(function (key) {
              return Core__Option.getOr(candidatesMap.get(key), []);
            });
        [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9
          ].forEach(function (value) {
              if (rowCandidates.flat().filter(function (v) {
                      return v === value;
                    }).length === 1) {
                var index = rowCandidates.findIndex(function (candidates) {
                      return candidates.includes(value);
                    });
                sudoku[Core__Option.getExn(rowIndexes[index], undefined)] = value;
              }
              if (columnCandidates.flat().filter(function (v) {
                      return v === value;
                    }).length === 1) {
                var index$1 = columnCandidates.findIndex(function (candidates) {
                      return candidates.includes(value);
                    });
                sudoku[Core__Option.getExn(columnIndexes[index$1], undefined)] = value;
              }
              if (boxCandidates.flat().filter(function (v) {
                      return v === value;
                    }).length !== 1) {
                return ;
              }
              var index$2 = boxCandidates.findIndex(function (candidates) {
                    return candidates.includes(value);
                  });
              sudoku[Core__Option.getExn(boxIndexes[index$2], undefined)] = value;
            });
      });
  return sudoku;
}

function intersectionRemovalStrategy(sudoku) {
  var candidatesMap = toCandidates(sudoku);
  Array.from(candidatesMap.entries()).forEach(function (param) {
        var key = param[0];
        var rowIndexes = getRowKeysForKey(key);
        var columnIndexes = getColumnKeysForKey(key);
        var boxIndexes = getBoxKeysForKey(key);
        var getCandidates = function (indexes) {
          return indexes.map(function (index) {
                        return Core__Option.getOr(candidatesMap.get(index), []);
                      }).map(function (candidates, index) {
                      return {
                              unitCandidates: candidates,
                              index: index,
                              key: Core__Option.getExn(boxIndexes[index], undefined)
                            };
                    });
        };
        var getPairs = function (candidates) {
          return candidates.filter(function (param, index) {
                      var unitCandidates = param.unitCandidates;
                      if (unitCandidates.length === 2) {
                        return candidates.some(function (param, i) {
                                    if (index !== i) {
                                      return Caml_obj.equal(unitCandidates, param.unitCandidates);
                                    } else {
                                      return false;
                                    }
                                  });
                      } else {
                        return false;
                      }
                    });
        };
        var removeCandidate = function (key, candidate) {
          var candidates = Core__Option.getOr(candidatesMap.get(key), []);
          candidatesMap.set(key, candidates.filter(function (c) {
                    return c !== candidate;
                  }));
        };
        var getCandidatesThatMustExistInBox = function (boxIndexes, boxCandidates) {
          var candidates = boxCandidates.map(function (param) {
                return param.unitCandidates;
              });
          var indexes = [
              0,
              1,
              2
            ].map(function (n) {
                return Math.imul(n, 3);
              });
          var boxRowCandidates = indexes.map(function (start, end) {
                var end$1 = indexes[end + 1 | 0];
                if (end$1 !== undefined) {
                  return candidates.slice(start, end$1).flat();
                } else {
                  return candidates.slice(start).flat();
                }
              });
          var indexes$1 = [
            0,
            1,
            2
          ];
          var boxColumnCandidates = indexes$1.map(function (columnIndex) {
                return candidates.filter(function (param, index) {
                              return index % 3 === columnIndex;
                            }).flat();
              });
          var isUniqueCandidate = function (currentBoxRowOrColumn, boxCandidates, candidate) {
            switch (currentBoxRowOrColumn) {
              case 0 :
                  if (Core__Option.getExn(boxCandidates[0], undefined).includes(candidate) && !Core__Option.getExn(boxCandidates[1], undefined).includes(candidate)) {
                    return !Core__Option.getExn(boxCandidates[2], undefined).includes(candidate);
                  } else {
                    return false;
                  }
              case 1 :
                  if (Core__Option.getExn(boxCandidates[1], undefined).includes(candidate) && !Core__Option.getExn(boxCandidates[0], undefined).includes(candidate)) {
                    return !Core__Option.getExn(boxCandidates[2], undefined).includes(candidate);
                  } else {
                    return false;
                  }
              case 2 :
                  if (Core__Option.getExn(boxCandidates[2], undefined).includes(candidate) && !Core__Option.getExn(boxCandidates[0], undefined).includes(candidate)) {
                    return !Core__Option.getExn(boxCandidates[1], undefined).includes(candidate);
                  } else {
                    return false;
                  }
              default:
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Solver.res",
                        314,
                        15
                      ],
                      Error: new Error()
                    };
            }
          };
          var n = boxIndexes.indexOf(key) / 3 | 0;
          var currentBoxRow = Math.floor(n) | 0;
          var currentBoxColumn = boxIndexes.indexOf(key) % 3;
          return Core__Array.reduce([
                      1,
                      2,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9
                    ], [
                      [],
                      []
                    ], (function (param, candidate) {
                        var uniqueColumnCandidates = param[1];
                        var uniqueRowCandidates = param[0];
                        var isUniqueRowCandidate = isUniqueCandidate(currentBoxRow, boxRowCandidates, candidate);
                        var isUniqueColumnCandidate = isUniqueCandidate(currentBoxColumn, boxColumnCandidates, candidate);
                        return [
                                isUniqueRowCandidate ? Belt_Array.concatMany([
                                        uniqueRowCandidates,
                                        [candidate]
                                      ]) : uniqueRowCandidates,
                                isUniqueColumnCandidate ? Belt_Array.concatMany([
                                        uniqueColumnCandidates,
                                        [candidate]
                                      ]) : uniqueColumnCandidates
                              ];
                      }));
        };
        var removePairCandidatesFromRemainderOfUnit = function (unitIndexes, pairs) {
          pairs.forEach(function (param) {
                var unitCandidates = param.unitCandidates;
                unitIndexes.forEach(function (index) {
                      var candidatesForIndex = Core__Option.getOr(candidatesMap.get(index), []);
                      if (Caml_obj.notequal(candidatesForIndex, unitCandidates) && candidatesForIndex.length > 0) {
                        unitCandidates.forEach(function (candidate) {
                              removeCandidate(index, candidate);
                            });
                        return ;
                      }
                      
                    });
              });
        };
        var rowCandidates = getCandidates(rowIndexes);
        var columnCandidates = getCandidates(columnIndexes);
        var boxCandidates = getCandidates(boxIndexes);
        var pairsInRow = getPairs(rowCandidates);
        var pairsInColumn = getPairs(columnCandidates);
        var pairsInBox = getPairs(boxCandidates);
        removePairCandidatesFromRemainderOfUnit(rowIndexes, pairsInRow);
        removePairCandidatesFromRemainderOfUnit(columnIndexes, pairsInColumn);
        removePairCandidatesFromRemainderOfUnit(boxIndexes, pairsInBox);
        var match = getCandidatesThatMustExistInBox(boxIndexes, boxCandidates);
        var columnCandidatesToRemoveOutsideOfBox = match[1];
        var rowCandidatesToRemoveOutsideOfBox = match[0];
        rowIndexes.filter(function (index) {
                return !boxIndexes.includes(index);
              }).forEach(function (index) {
              rowCandidatesToRemoveOutsideOfBox.forEach(function (candidate) {
                    removeCandidate(index, candidate);
                  });
            });
        boxIndexes.filter(function (index) {
                return !boxIndexes.includes(index);
              }).forEach(function (index) {
              columnCandidatesToRemoveOutsideOfBox.forEach(function (candidate) {
                    removeCandidate(index, candidate);
                  });
            });
      });
  return nakedCandidateStrategy(nakedSingleStrategy(sudoku, Caml_option.some(candidatesMap)), Caml_option.some(candidatesMap));
}

function easyStrategies(_sudoku) {
  while(true) {
    var sudoku = _sudoku;
    var originalSudoku = Belt_Array.concatMany([sudoku]);
    var sudoku$1 = nakedCandidateStrategy(nakedSingleStrategy(sudoku, undefined), undefined);
    if (Caml_obj.equal(originalSudoku, sudoku$1)) {
      return sudoku$1;
    }
    _sudoku = sudoku$1;
    continue ;
  };
}

function mediumStrategies(_sudoku) {
  while(true) {
    var sudoku = _sudoku;
    var originalSudoku = Belt_Array.concatMany([sudoku]);
    var sudoku$1 = nakedSingleStrategy(nakedCandidateStrategy(intersectionRemovalStrategy(sudoku), undefined), undefined);
    if (Caml_obj.equal(originalSudoku, sudoku$1)) {
      return sudoku$1;
    }
    _sudoku = sudoku$1;
    continue ;
  };
}

console.log(toRows(mediumStrategies(easyStrategies(sudoku))));

export {
  sudoku ,
  floor ,
  toRows ,
  toColumns ,
  toBoxes ,
  getRowKeysForKey ,
  getColumnKeysForKey ,
  getBoxKeysForKey ,
  toCandidates ,
  nakedSingleStrategy ,
  nakedCandidateStrategy ,
  intersectionRemovalStrategy ,
  easyStrategies ,
  mediumStrategies ,
}
/*  Not a pure module */
